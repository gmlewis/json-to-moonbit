pub struct AutoGenerated {
  booleanfield : Bool
  somearray : Array[Somearray]
  date : String
} derive(Show, Eq, ToJson)

pub fn AutoGenerated::new() -> AutoGenerated {
  {
    booleanfield: false,
    somearray: [],
    date: "",
  }
}

pub impl @json.FromJson for AutoGenerated with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json: expected object"),
      )
  }
  let booleanfield : Bool = match json.get("booleanfield") {
    Some(True) => true
    Some(False) => false
   _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:booleanfield expected Bool"))
  }
  let somearray : Array[Somearray] = match json.get("somearray") {
    Some(Array(somearray)) => somearray_array_from_json!(somearray)
    e => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:somearray: expected Array: got \{e}"))
  }
  let date : String = match json.get("date") {
    Some(String(date)) => date
    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:date: expected String"))
  }
  {
    booleanfield,
    somearray,
    date,
  }
}

pub fn somearray_array_from_json(json : Array[Json]) -> Array[Somearray]!@json.JsonDecodeError {
  let arr: Array[Somearray] = Array::new(capacity = json.length())
  each_exn!(
    json,
    fn(jv) {
      let el : Somearray = @json.from_json!(jv)
      arr.push(el)
    }
  )
  arr
}

pub struct Somearray {
  id : Json
  name : String
  features : Json
} derive(Show, Eq, ToJson)

pub fn Somearray::new() -> Somearray {
  {
    id: Null,
    name: "",
    features: Null,
  }
}

pub impl @json.FromJson for Somearray with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "Somearray::from_json: expected object"),
      )
  }
  let id : Json = match json.get("id") {
    Some(id) => id
    _ => raise @json.JsonDecodeError((path, "Somearray::from_json:id expected valid Json"))
  }
  let name : String = match json.get("name") {
    Some(String(name)) => name
    _ => raise @json.JsonDecodeError((path, "Somearray::from_json:name: expected String"))
  }
  let features : Json = match json.get("features") {
    Some(features) => features
    _ => raise @json.JsonDecodeError((path, "Somearray::from_json:features expected valid Json"))
  }
  {
    id,
    name,
    features,
  }
}

fn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {
  for i = 0; i < arr.length(); i = i + 1 {
    func!(arr[i])
  }
}
