pub struct AutoGenerated {
  people : Array[People]
} derive(Show, Eq, ToJson)

pub fn AutoGenerated::new() -> AutoGenerated {
  { people: [] }
}

pub impl @json.FromJson for AutoGenerated with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json: expected object"),
      )
  }
  let people : Array[People] = match json.get("people") {
    Some(Array(people)) => people_array_from_json!(people)
    e =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json:people: expected Array: got \{e}"),
      )
  }
  { people, }
}

pub fn people_array_from_json(
  json : Array[Json]
) -> Array[People]!@json.JsonDecodeError {
  let arr : Array[People] = Array::new(capacity=json.length())
  each_exn!(
    json,
    fn(jv) {
      let el : People = @json.from_json!(jv)
      arr.push(el)
    },
  )
  arr
}

pub struct People {
  name : String
} derive(Show, Eq, ToJson)

pub fn People::new() -> People {
  { name: "" }
}

pub impl @json.FromJson for People with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError((path, "People::from_json: expected object"))
  }
  let name : String = match json.get("name") {
    Some(String(name)) => name
    _ =>
      raise @json.JsonDecodeError(
        (path, "People::from_json:name: expected String"),
      )
  }
  { name, }
}

fn each_exn[T](
  arr : Array[T],
  func : (T) -> Unit!@json.JsonDecodeError
) -> Unit!@json.JsonDecodeError {
  for i = 0; i < arr.length(); i = i + 1 {
    func!(arr[i])
  }
}
