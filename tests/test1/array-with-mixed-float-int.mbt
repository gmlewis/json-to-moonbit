pub struct AutoGenerated {
  age_of_the_universe : Array[AgeOfTheUniverse]
  age_of_the_earth : Array[AgeOfTheEarth]
  date : String
} derive(Show, Eq)

pub fn AutoGenerated::new() -> AutoGenerated {
  { age_of_the_universe: [], age_of_the_earth: [], date: "" }
}

pub fn to_json(self : AutoGenerated) -> Json {
  let json : Map[String, Json] = {}
  json["age of the universe"] = self.age_of_the_universe.to_json()
  json["age of the earth"] = self.age_of_the_earth.to_json()
  json["date"] = self.date.to_json()
  json.to_json()
}

pub impl @json.FromJson for AutoGenerated with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json: expected object"),
      )
  }
  let age_of_the_universe : Array[AgeOfTheUniverse] = match
    json.get("age of the universe") {
    Some(Array(age_of_the_universe)) =>
      age_of_the_universe_array_from_json!(age_of_the_universe)
    e =>
      raise @json.JsonDecodeError(
        (
          path,
          "AutoGenerated::from_json:age_of_the_universe: expected Array: got \{e}",
        ),
      )
  }
  let age_of_the_earth : Array[AgeOfTheEarth] = match
    json.get("age of the earth") {
    Some(Array(age_of_the_earth)) =>
      age_of_the_earth_array_from_json!(age_of_the_earth)
    e =>
      raise @json.JsonDecodeError(
        (
          path,
          "AutoGenerated::from_json:age_of_the_earth: expected Array: got \{e}",
        ),
      )
  }
  let date : String = match json.get("date") {
    Some(String(date)) => date
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json:date: expected String"),
      )
  }
  { age_of_the_universe, age_of_the_earth, date }
}

pub fn age_of_the_universe_array_from_json(
  json : Array[Json]
) -> Array[AgeOfTheUniverse]!@json.JsonDecodeError {
  let arr : Array[AgeOfTheUniverse] = Array::new(capacity=json.length())
  each_exn!(
    json,
    fn(jv) {
      let el : AgeOfTheUniverse = @json.from_json!(jv)
      arr.push(el)
    },
  )
  arr
}

pub fn age_of_the_earth_array_from_json(
  json : Array[Json]
) -> Array[AgeOfTheEarth]!@json.JsonDecodeError {
  let arr : Array[AgeOfTheEarth] = Array::new(capacity=json.length())
  each_exn!(
    json,
    fn(jv) {
      let el : AgeOfTheEarth = @json.from_json!(jv)
      arr.push(el)
    },
  )
  arr
}

pub struct AgeOfTheUniverse {
  name : String
  value : Double
} derive(Show, Eq, ToJson)

pub fn AgeOfTheUniverse::new() -> AgeOfTheUniverse {
  { name: "", value: 0 }
}

pub impl @json.FromJson for AgeOfTheUniverse with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AgeOfTheUniverse::from_json: expected object"),
      )
  }
  let name : String = match json.get("name") {
    Some(String(name)) => name
    _ =>
      raise @json.JsonDecodeError(
        (path, "AgeOfTheUniverse::from_json:name: expected String"),
      )
  }
  let value : Double = match json.get("value") {
    Some(Number(value)) => value
    _ =>
      raise @json.JsonDecodeError(
        (path, "AgeOfTheUniverse::from_json:value: expected Double"),
      )
  }
  { name, value }
}

pub struct AgeOfTheEarth {
  name : String
  value : Int64
} derive(Show, Eq, ToJson)

pub fn AgeOfTheEarth::new() -> AgeOfTheEarth {
  { name: "", value: 0 }
}

pub impl @json.FromJson for AgeOfTheEarth with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AgeOfTheEarth::from_json: expected object"),
      )
  }
  let name : String = match json.get("name") {
    Some(String(name)) => name
    _ =>
      raise @json.JsonDecodeError(
        (path, "AgeOfTheEarth::from_json:name: expected String"),
      )
  }
  let value : Int64 = match json.get("value") {
    Some(Number(value)) => value.to_int64()
    _ =>
      raise @json.JsonDecodeError(
        (path, "AgeOfTheEarth::from_json:value expected Int64"),
      )
  }
  { name, value }
}

fn each_exn[T](
  arr : Array[T],
  func : (T) -> Unit!@json.JsonDecodeError
) -> Unit!@json.JsonDecodeError {
  for i = 0; i < arr.length(); i = i + 1 {
    func!(arr[i])
  }
}
