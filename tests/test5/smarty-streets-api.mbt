pub struct AutoGenerated {
  auto_generated_array : Array[AutoGeneratedArray]
} derive(Show, Eq)

pub fn to_json(self : AutoGenerated) -> Json {
  self.auto_generated_array.to_json()
}

pub impl @json.FromJson for AutoGenerated with from_json(json, path) {
  let json = match json {
    Array(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json: expected array"),
      )
  }
  let auto_generated_array : Array[AutoGeneratedArray] = Array::new(
    capacity=json.length(),
  )
  each_exn!(
    json,
    fn(jv) {
      let el : AutoGeneratedArray = @json.from_json!(jv)
      auto_generated_array.push(el)
    },
  )
  { auto_generated_array, }
}

pub struct AutoGeneratedArray {
  input_index : Int
  candidate_index : Int
  delivery_line1 : String
  last_line : String
  delivery_point_barcode : String
  components : Components
  metadata : Metadata
  analysis : Analysis
} derive(Show, Eq)

pub fn AutoGeneratedArray::new() -> AutoGeneratedArray {
  {
    input_index: 0,
    candidate_index: 0,
    delivery_line1: "",
    last_line: "",
    delivery_point_barcode: "",
    components: Components::new(),
    metadata: Metadata::new(),
    analysis: Analysis::new(),
  }
}

pub fn to_json(self : AutoGeneratedArray) -> Json {
  let json : Map[String, Json] = {}
  json["input_index"] = self.input_index.to_json()
  json["candidate_index"] = self.candidate_index.to_json()
  json["delivery_line_1"] = self.delivery_line1.to_json()
  json["last_line"] = self.last_line.to_json()
  json["delivery_point_barcode"] = self.delivery_point_barcode.to_json()
  json["components"] = self.components.to_json()
  json["metadata"] = self.metadata.to_json()
  json["analysis"] = self.analysis.to_json()
  json.to_json()
}

pub impl @json.FromJson for AutoGeneratedArray with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json: expected object"),
      )
  }
  let input_index : Int = match json.get("input_index") {
    Some(Number(input_index)) => input_index.to_int()
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:input_index expected Int"),
      )
  }
  let candidate_index : Int = match json.get("candidate_index") {
    Some(Number(candidate_index)) => candidate_index.to_int()
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:candidate_index expected Int"),
      )
  }
  let delivery_line1 : String = match json.get("delivery_line_1") {
    Some(String(delivery_line1)) => delivery_line1
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:delivery_line1: expected String"),
      )
  }
  let last_line : String = match json.get("last_line") {
    Some(String(last_line)) => last_line
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:last_line: expected String"),
      )
  }
  let delivery_point_barcode : String = match
    json.get("delivery_point_barcode") {
    Some(String(delivery_point_barcode)) => delivery_point_barcode
    _ =>
      raise @json.JsonDecodeError(
        (
          path, "AutoGeneratedArray::from_json:delivery_point_barcode: expected String",
        ),
      )
  }
  let components : Components = match json.get("components") {
    Some(Object(components)) => @json.from_json!(components.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:components expected Components"),
      )
  }
  let metadata : Metadata = match json.get("metadata") {
    Some(Object(metadata)) => @json.from_json!(metadata.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:metadata expected Metadata"),
      )
  }
  let analysis : Analysis = match json.get("analysis") {
    Some(Object(analysis)) => @json.from_json!(analysis.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGeneratedArray::from_json:analysis expected Analysis"),
      )
  }
  {
    input_index,
    candidate_index,
    delivery_line1,
    last_line,
    delivery_point_barcode,
    components,
    metadata,
    analysis,
  }
}

pub struct Components {
  primary_number : String
  street_predirection : String
  street_name : String
  street_suffix : String
  city_name : String
  state_abbreviation : String
  zipcode : String
  plus4_code : String
  delivery_point : String
  delivery_point_check_digit : String
} derive(Show, Eq, ToJson)

pub fn Components::new() -> Components {
  {
    primary_number: "",
    street_predirection: "",
    street_name: "",
    street_suffix: "",
    city_name: "",
    state_abbreviation: "",
    zipcode: "",
    plus4_code: "",
    delivery_point: "",
    delivery_point_check_digit: "",
  }
}

pub impl @json.FromJson for Components with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json: expected object"),
      )
  }
  let primary_number : String = match json.get("primary_number") {
    Some(String(primary_number)) => primary_number
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:primary_number: expected String"),
      )
  }
  let street_predirection : String = match json.get("street_predirection") {
    Some(String(street_predirection)) => street_predirection
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:street_predirection: expected String"),
      )
  }
  let street_name : String = match json.get("street_name") {
    Some(String(street_name)) => street_name
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:street_name: expected String"),
      )
  }
  let street_suffix : String = match json.get("street_suffix") {
    Some(String(street_suffix)) => street_suffix
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:street_suffix: expected String"),
      )
  }
  let city_name : String = match json.get("city_name") {
    Some(String(city_name)) => city_name
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:city_name: expected String"),
      )
  }
  let state_abbreviation : String = match json.get("state_abbreviation") {
    Some(String(state_abbreviation)) => state_abbreviation
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:state_abbreviation: expected String"),
      )
  }
  let zipcode : String = match json.get("zipcode") {
    Some(String(zipcode)) => zipcode
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:zipcode: expected String"),
      )
  }
  let plus4_code : String = match json.get("plus4_code") {
    Some(String(plus4_code)) => plus4_code
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:plus4_code: expected String"),
      )
  }
  let delivery_point : String = match json.get("delivery_point") {
    Some(String(delivery_point)) => delivery_point
    _ =>
      raise @json.JsonDecodeError(
        (path, "Components::from_json:delivery_point: expected String"),
      )
  }
  let delivery_point_check_digit : String = match
    json.get("delivery_point_check_digit") {
    Some(String(delivery_point_check_digit)) => delivery_point_check_digit
    _ =>
      raise @json.JsonDecodeError(
        (
          path, "Components::from_json:delivery_point_check_digit: expected String",
        ),
      )
  }
  {
    primary_number,
    street_predirection,
    street_name,
    street_suffix,
    city_name,
    state_abbreviation,
    zipcode,
    plus4_code,
    delivery_point,
    delivery_point_check_digit,
  }
}

pub struct Metadata {
  record_type : String
  zip_type : String
  county_fips : String
  county_name : String
  carrier_route : String
  congressional_district : String
  rdi : String
  elot_sequence : String
  elot_sort : String
  latitude : Double
  longitude : Double
  precision : String
  time_zone : String
  utc_offset : Int
  dst : Bool
} derive(Show, Eq, ToJson)

pub fn Metadata::new() -> Metadata {
  {
    record_type: "",
    zip_type: "",
    county_fips: "",
    county_name: "",
    carrier_route: "",
    congressional_district: "",
    rdi: "",
    elot_sequence: "",
    elot_sort: "",
    latitude: 0,
    longitude: 0,
    precision: "",
    time_zone: "",
    utc_offset: 0,
    dst: false,
  }
}

pub impl @json.FromJson for Metadata with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json: expected object"),
      )
  }
  let record_type : String = match json.get("record_type") {
    Some(String(record_type)) => record_type
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:record_type: expected String"),
      )
  }
  let zip_type : String = match json.get("zip_type") {
    Some(String(zip_type)) => zip_type
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:zip_type: expected String"),
      )
  }
  let county_fips : String = match json.get("county_fips") {
    Some(String(county_fips)) => county_fips
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:county_fips: expected String"),
      )
  }
  let county_name : String = match json.get("county_name") {
    Some(String(county_name)) => county_name
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:county_name: expected String"),
      )
  }
  let carrier_route : String = match json.get("carrier_route") {
    Some(String(carrier_route)) => carrier_route
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:carrier_route: expected String"),
      )
  }
  let congressional_district : String = match
    json.get("congressional_district") {
    Some(String(congressional_district)) => congressional_district
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:congressional_district: expected String"),
      )
  }
  let rdi : String = match json.get("rdi") {
    Some(String(rdi)) => rdi
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:rdi: expected String"),
      )
  }
  let elot_sequence : String = match json.get("elot_sequence") {
    Some(String(elot_sequence)) => elot_sequence
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:elot_sequence: expected String"),
      )
  }
  let elot_sort : String = match json.get("elot_sort") {
    Some(String(elot_sort)) => elot_sort
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:elot_sort: expected String"),
      )
  }
  let latitude : Double = match json.get("latitude") {
    Some(Number(latitude)) => latitude
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:latitude: expected Double"),
      )
  }
  let longitude : Double = match json.get("longitude") {
    Some(Number(longitude)) => longitude
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:longitude: expected Double"),
      )
  }
  let precision : String = match json.get("precision") {
    Some(String(precision)) => precision
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:precision: expected String"),
      )
  }
  let time_zone : String = match json.get("time_zone") {
    Some(String(time_zone)) => time_zone
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:time_zone: expected String"),
      )
  }
  let utc_offset : Int = match json.get("utc_offset") {
    Some(Number(utc_offset)) => utc_offset.to_int()
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:utc_offset expected Int"),
      )
  }
  let dst : Bool = match json.get("dst") {
    Some(True) => true
    Some(False) => false
    _ =>
      raise @json.JsonDecodeError(
        (path, "Metadata::from_json:dst expected Bool"),
      )
  }
  {
    record_type,
    zip_type,
    county_fips,
    county_name,
    carrier_route,
    congressional_district,
    rdi,
    elot_sequence,
    elot_sort,
    latitude,
    longitude,
    precision,
    time_zone,
    utc_offset,
    dst,
  }
}

pub struct Analysis {
  dpv_match_code : String
  dpv_footnotes : String
  dpv_cmra : String
  dpv_vacant : String
  active : String
} derive(Show, Eq, ToJson)

pub fn Analysis::new() -> Analysis {
  {
    dpv_match_code: "",
    dpv_footnotes: "",
    dpv_cmra: "",
    dpv_vacant: "",
    active: "",
  }
}

pub impl @json.FromJson for Analysis with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "Analysis::from_json: expected object"),
      )
  }
  let dpv_match_code : String = match json.get("dpv_match_code") {
    Some(String(dpv_match_code)) => dpv_match_code
    _ =>
      raise @json.JsonDecodeError(
        (path, "Analysis::from_json:dpv_match_code: expected String"),
      )
  }
  let dpv_footnotes : String = match json.get("dpv_footnotes") {
    Some(String(dpv_footnotes)) => dpv_footnotes
    _ =>
      raise @json.JsonDecodeError(
        (path, "Analysis::from_json:dpv_footnotes: expected String"),
      )
  }
  let dpv_cmra : String = match json.get("dpv_cmra") {
    Some(String(dpv_cmra)) => dpv_cmra
    _ =>
      raise @json.JsonDecodeError(
        (path, "Analysis::from_json:dpv_cmra: expected String"),
      )
  }
  let dpv_vacant : String = match json.get("dpv_vacant") {
    Some(String(dpv_vacant)) => dpv_vacant
    _ =>
      raise @json.JsonDecodeError(
        (path, "Analysis::from_json:dpv_vacant: expected String"),
      )
  }
  let active : String = match json.get("active") {
    Some(String(active)) => active
    _ =>
      raise @json.JsonDecodeError(
        (path, "Analysis::from_json:active: expected String"),
      )
  }
  { dpv_match_code, dpv_footnotes, dpv_cmra, dpv_vacant, active }
}

fn each_exn[T](
  arr : Array[T],
  func : (T) -> Unit!@json.JsonDecodeError
) -> Unit!@json.JsonDecodeError {
  for i = 0; i < arr.length(); i = i + 1 {
    func!(arr[i])
  }
}
