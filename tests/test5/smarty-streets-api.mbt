pub struct AutoGenerated {
  auto_generated_array : Array[AutoGeneratedArray]
} derive(Show, Eq)

pub fn to_json(self : AutoGenerated) -> Json {
  self.auto_generated_array.to_json()
}

pub impl @json.FromJson for AutoGenerated with from_json(json, path) {
  let json = match json {
    Array(json) => json
    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected array"))
  }
  let auto_generated_array: Array[AutoGeneratedArray] = Array::new(capacity = json.length())
  each_exn!(
    json,
    fn(jv) {
      let el : AutoGeneratedArray = @json.from_json!(jv)
      auto_generated_array.push(el)
    }
  )
  { auto_generated_array, }
}

pub struct AutoGeneratedArray {
  input_index : Int
  candidate_index : Int
  delivery_line1 : String
  last_line : String
  delivery_point_barcode : String
  components : Components
  metadata : Metadata
  analysis : Analysis
} derive(Show, Eq)

pub fn to_json(self : AutoGeneratedArray) -> Json {
  {
    "input_index": self.input_index.to_json(),
    "candidate_index": self.candidate_index.to_json(),
    "delivery_line_1": self.delivery_line1.to_json(),
    "last_line": self.last_line.to_json(),
    "delivery_point_barcode": self.delivery_point_barcode.to_json(),
    "components": self.components.to_json(),
    "metadata": self.metadata.to_json(),
    "analysis": self.analysis.to_json(),
  }
}

pub impl @json.FromJson for AutoGeneratedArray with from_json(json, path) {
  match json {
    {
      "input_index": Number(input_index),
      "candidate_index": Number(candidate_index),
      "delivery_line_1": String(delivery_line1),
      "last_line": String(last_line),
      "delivery_point_barcode": String(delivery_point_barcode),
      "components": components,
      "metadata": metadata,
      "analysis": analysis,
    } => {
      let input_index = input_index.to_int()
      let candidate_index = candidate_index.to_int()
      let components : Components = @json.from_json!(components)
      let metadata : Metadata = @json.from_json!(metadata)
      let analysis : Analysis = @json.from_json!(analysis)
      {
        input_index,
        candidate_index,
        delivery_line1,
        last_line,
        delivery_point_barcode,
        components,
        metadata,
        analysis,
      }
    }
    _ => raise @json.JsonDecodeError((path, "AutoGeneratedArray::from_json: expected object"))
  }
}

pub struct Components {
  primary_number : String
  street_predirection : String
  street_name : String
  street_suffix : String
  city_name : String
  state_abbreviation : String
  zipcode : String
  plus4_code : String
  delivery_point : String
  delivery_point_check_digit : String
} derive(Show, Eq, ToJson)

pub impl @json.FromJson for Components with from_json(json, path) {
  match json {
    {
      "primary_number": String(primary_number),
      "street_predirection": String(street_predirection),
      "street_name": String(street_name),
      "street_suffix": String(street_suffix),
      "city_name": String(city_name),
      "state_abbreviation": String(state_abbreviation),
      "zipcode": String(zipcode),
      "plus4_code": String(plus4_code),
      "delivery_point": String(delivery_point),
      "delivery_point_check_digit": String(delivery_point_check_digit),
    } => {
      {
        primary_number,
        street_predirection,
        street_name,
        street_suffix,
        city_name,
        state_abbreviation,
        zipcode,
        plus4_code,
        delivery_point,
        delivery_point_check_digit,
      }
    }
    _ => raise @json.JsonDecodeError((path, "Components::from_json: expected object"))
  }
}

pub struct Metadata {
  record_type : String
  zip_type : String
  county_fips : String
  county_name : String
  carrier_route : String
  congressional_district : String
  rdi : String
  elot_sequence : String
  elot_sort : String
  latitude : Double
  longitude : Double
  precision : String
  time_zone : String
  utc_offset : Int
  dst : Bool
} derive(Show, Eq, ToJson)

pub impl @json.FromJson for Metadata with from_json(json, path) {
  match json {
    {
      "record_type": String(record_type),
      "zip_type": String(zip_type),
      "county_fips": String(county_fips),
      "county_name": String(county_name),
      "carrier_route": String(carrier_route),
      "congressional_district": String(congressional_district),
      "rdi": String(rdi),
      "elot_sequence": String(elot_sequence),
      "elot_sort": String(elot_sort),
      "latitude": Number(latitude),
      "longitude": Number(longitude),
      "precision": String(precision),
      "time_zone": String(time_zone),
      "utc_offset": Number(utc_offset),
      "dst": dst,
    } => {
      let utc_offset = utc_offset.to_int()
      let dst = dst.as_bool().or_error!(@json.JsonDecodeError((path, "unable to parse bool")))
      {
        record_type,
        zip_type,
        county_fips,
        county_name,
        carrier_route,
        congressional_district,
        rdi,
        elot_sequence,
        elot_sort,
        latitude,
        longitude,
        precision,
        time_zone,
        utc_offset,
        dst,
      }
    }
    _ => raise @json.JsonDecodeError((path, "Metadata::from_json: expected object"))
  }
}

pub struct Analysis {
  dpv_match_code : String
  dpv_footnotes : String
  dpv_cmra : String
  dpv_vacant : String
  active : String
} derive(Show, Eq, ToJson)

pub impl @json.FromJson for Analysis with from_json(json, path) {
  match json {
    {
      "dpv_match_code": String(dpv_match_code),
      "dpv_footnotes": String(dpv_footnotes),
      "dpv_cmra": String(dpv_cmra),
      "dpv_vacant": String(dpv_vacant),
      "active": String(active),
    } => {
      {
        dpv_match_code,
        dpv_footnotes,
        dpv_cmra,
        dpv_vacant,
        active,
      }
    }
    _ => raise @json.JsonDecodeError((path, "Analysis::from_json: expected object"))
  }
}

fn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {
  for i = 0; i < arr.length(); i = i + 1 {
    func!(arr[i])
  }
}
