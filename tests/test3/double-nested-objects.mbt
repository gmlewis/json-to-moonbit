pub struct AutoGenerated {
  first : First
  second : Second
} derive(Show, Eq, ToJson, FromJson)

pub fn AutoGenerated::new() -> AutoGenerated {
  {
    first: First::new(),
    second: Second::new(),
  }
}

pub struct Type {
  short : String
  long : String
} derive(Show, Eq, ToJson, FromJson)

pub fn Type::new() -> Type {
  {
    short: "",
    long: "",
  }
}

pub struct First {
  id : Int
  type_ : Type
} derive(Show, Eq)

pub fn First::new() -> First {
  {
    id: 0,
    type_: Type::new(),
  }
}

pub fn to_json(self : First) -> Json {
  let json : Map[String, Json] = {}
  json["id"] = self.id.to_json()
  json["type"] = self.type_.to_json()
  json.to_json()
}

pub impl @json.FromJson for First with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "First::from_json: expected object"),
      )
  }
  let id : Int = match json.get("id") {
    Some(Number(id)) => id.to_int()
    _ => raise @json.JsonDecodeError((path, "First::from_json:id expected Int"))
  }
  let type_ : Type = match json.get("type") {
    Some(Object(type_)) => @json.from_json!(type_.to_json())
    _ => raise @json.JsonDecodeError((path, "First::from_json:type_ expected Type"))
  }
  {
    id,
    type_,
  }
}

pub struct SecondType {
  long : String
} derive(Show, Eq, ToJson, FromJson)

pub fn SecondType::new() -> SecondType {
  {
    long: "",
  }
}

pub struct Second {
  id : Int
  second_type : SecondType
} derive(Show, Eq)

pub fn Second::new() -> Second {
  {
    id: 0,
    second_type: SecondType::new(),
  }
}

pub fn to_json(self : Second) -> Json {
  let json : Map[String, Json] = {}
  json["id"] = self.id.to_json()
  json["type"] = self.second_type.to_json()
  json.to_json()
}

pub impl @json.FromJson for Second with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "Second::from_json: expected object"),
      )
  }
  let id : Int = match json.get("id") {
    Some(Number(id)) => id.to_int()
    _ => raise @json.JsonDecodeError((path, "Second::from_json:id expected Int"))
  }
  let second_type : SecondType = match json.get("type") {
    Some(Object(second_type)) => @json.from_json!(second_type.to_json())
    _ => raise @json.JsonDecodeError((path, "Second::from_json:second_type expected SecondType"))
  }
  {
    id,
    second_type,
  }
}
