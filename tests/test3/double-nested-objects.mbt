pub struct AutoGenerated {
  first : First
  second : Second
} derive(Show, Eq, ToJson)

pub fn AutoGenerated::new() -> AutoGenerated {
  { first: First::new(), second: Second::new() }
}

pub impl @json.FromJson for AutoGenerated with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json: expected object"),
      )
  }
  let first : First = match json.get("first") {
    Some(Object(first)) => @json.from_json!(first.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json:first expected First"),
      )
  }
  let second : Second = match json.get("second") {
    Some(Object(second)) => @json.from_json!(second.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "AutoGenerated::from_json:second expected Second"),
      )
  }
  { first, second }
}

pub struct Type {
  short : String
  long : String
} derive(Show, Eq, ToJson)

pub fn Type::new() -> Type {
  { short: "", long: "" }
}

pub impl @json.FromJson for Type with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ => raise @json.JsonDecodeError((path, "Type::from_json: expected object"))
  }
  let short : String = match json.get("short") {
    Some(String(short)) => short
    _ =>
      raise @json.JsonDecodeError(
        (path, "Type::from_json:short: expected String"),
      )
  }
  let long : String = match json.get("long") {
    Some(String(long)) => long
    _ =>
      raise @json.JsonDecodeError(
        (path, "Type::from_json:long: expected String"),
      )
  }
  { short, long }
}

pub struct First {
  id : Int
  type_ : Type
} derive(Show, Eq)

pub fn First::new() -> First {
  { id: 0, type_: Type::new() }
}

pub fn to_json(self : First) -> Json {
  let json : Map[String, Json] = {}
  json["id"] = self.id.to_json()
  json["type"] = self.type_.to_json()
  json.to_json()
}

pub impl @json.FromJson for First with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError((path, "First::from_json: expected object"))
  }
  let id : Int = match json.get("id") {
    Some(Number(id)) => id.to_int()
    _ => raise @json.JsonDecodeError((path, "First::from_json:id expected Int"))
  }
  let type_ : Type = match json.get("type") {
    Some(Object(type_)) => @json.from_json!(type_.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "First::from_json:type_ expected Type"),
      )
  }
  { id, type_ }
}

pub struct SecondType {
  long : String
} derive(Show, Eq, ToJson)

pub fn SecondType::new() -> SecondType {
  { long: "" }
}

pub impl @json.FromJson for SecondType with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError(
        (path, "SecondType::from_json: expected object"),
      )
  }
  let long : String = match json.get("long") {
    Some(String(long)) => long
    _ =>
      raise @json.JsonDecodeError(
        (path, "SecondType::from_json:long: expected String"),
      )
  }
  { long, }
}

pub struct Second {
  id : Int
  second_type : SecondType
} derive(Show, Eq)

pub fn Second::new() -> Second {
  { id: 0, second_type: SecondType::new() }
}

pub fn to_json(self : Second) -> Json {
  let json : Map[String, Json] = {}
  json["id"] = self.id.to_json()
  json["type"] = self.second_type.to_json()
  json.to_json()
}

pub impl @json.FromJson for Second with from_json(json, path) {
  let json = match json.as_object() {
    Some(json) => json
    _ =>
      raise @json.JsonDecodeError((path, "Second::from_json: expected object"))
  }
  let id : Int = match json.get("id") {
    Some(Number(id)) => id.to_int()
    _ =>
      raise @json.JsonDecodeError((path, "Second::from_json:id expected Int"))
  }
  let second_type : SecondType = match json.get("type") {
    Some(Object(second_type)) => @json.from_json!(second_type.to_json())
    _ =>
      raise @json.JsonDecodeError(
        (path, "Second::from_json:second_type expected SecondType"),
      )
  }
  { id, second_type }
}
