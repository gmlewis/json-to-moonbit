// -*- compile-command: "bun json-to-moonbit.test.js"; -*-

const jsonToMoonBit = require("./json-to-moonbit")
const Diff = require('./diff.min')

function quote(str) {
  return "`" + str
    .replace(/\t/g, '  ')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/'/g, "\\'") + "`,"
}

function test(includeExampleData) {
  const testCases = [
    {
      input: '{"html_url":"a","ssh_url":"b"}',
      expected: `pub struct AutoGenerated {\n  html_url : String\n  ssh_url : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    html_url: "",\n    ssh_url: "",\n  }\n}\n`,
    },
    {
      input: '{"SourceCode": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["SourceCode"] = self.source_code.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let source_code : String = match json.get("SourceCode") {\n    Some(String(source_code)) => source_code\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:source_code: expected String"))\n  }\n  {\n    source_code,\n  }\n}\n`,
    },
    {
      input: '{"source_code": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n`,
    },
    {
      input: '{"sourceCode": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  sourceCode : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    sourceCode: "",\n  }\n}\n`,
    },
    {
      input: '{"SOURCE_CODE": ""}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["SOURCE_CODE"] = self.source_code.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let source_code : String = match json.get("SOURCE_CODE") {\n    Some(String(source_code)) => source_code\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:source_code: expected String"))\n  }\n  {\n    source_code,\n  }\n}\n`,
    },
    {
      input: '{"PublicIP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["PublicIP"] = self.public_ip.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("PublicIP") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"public_ip": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n`,
    },
    {
      input: '{"publicIP": ""}',
      expected: `pub struct AutoGenerated {\n  publicIP : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    publicIP: "",\n  }\n}\n`,
    },
    {
      input: '{"publicIp": ""}',
      expected: `pub struct AutoGenerated {\n  publicIp : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    publicIp: "",\n  }\n}\n`,
    },
    {
      input: '{"PUBLIC_IP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["PUBLIC_IP"] = self.public_ip.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("PUBLIC_IP") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"+1": "Fails", "-1": "This should not cause duplicate field name"}',
      expected: `pub struct AutoGenerated {\n  num1 : String\n  num10 : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    num1: "",\n    num10: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["+1"] = self.num1.to_json()\n  json["-1"] = self.num10.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let num1 : String = match json.get("+1") {\n    Some(String(num1)) => num1\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:num1: expected String"))\n  }\n  let num10 : String = match json.get("-1") {\n    Some(String(num10)) => num10\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:num10: expected String"))\n  }\n  {\n    num1,\n    num10,\n  }\n}\n`,
    },
    {
      input: '{"age": 46}',
      expected: `pub struct AutoGenerated {\n  age : Int\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    age: 0,\n  }\n}\n`,
    },
    {
      input: '{"negativeFloat": -1.00}',
      expected: `pub struct AutoGenerated {\n  negativeFloat : Double\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    negativeFloat: 0,\n  }\n}\n`,
    },
    {
      input: '{"zeroFloat": 0.00}',
      expected: `pub struct AutoGenerated {\n  zeroFloat : Double\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    zeroFloat: 0,\n  }\n}\n`,
    },
    {
      input: '{"positiveFloat": 1.00}',
      expected: `pub struct AutoGenerated {\n  positiveFloat : Double\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    positiveFloat: 0,\n  }\n}\n`,
    },
    {
      input: '{"negativeFloats": [-1.00, -2.00, -3.00]}',
      expected: `pub struct AutoGenerated {\n  negativeFloats : Array[Double]\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    negativeFloats: [],\n  }\n}\n`,
    },
    {
      input: '{"zeroFloats": [0.00, 0.00, 0.00]}',
      expected: `pub struct AutoGenerated {\n  zeroFloats : Array[Double]\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    zeroFloats: [],\n  }\n}\n`,
    },
    {
      input: '{"positiveFloats": [1.00, 2.00, 3.00]}',
      expected: `pub struct AutoGenerated {\n  positiveFloats : Array[Double]\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    positiveFloats: [],\n  }\n}\n`,
    },
    {
      input: '{"topLevel": { "secondLevel": "exampleDataHere"} }',
      expected: `pub struct AutoGenerated {\n  topLevel : TopLevel\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    topLevel: TopLevel::new(),\n  }\n}\n\npub struct TopLevel {\n  secondLevel : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn TopLevel::new() -> TopLevel {\n  {\n    secondLevel: "",\n  }\n}\n`,
    },
    {
      input: '{"people": [{ "name": "Frank"}, {"name": "Dennis"}, {"name": "Dee"}, {"name": "Charley"}, {"name":"Mac"}] }',
      expected: `pub struct AutoGenerated {\n  people : Array[People]\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    people: [],\n  }\n}\n\npub struct People {\n  name : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn People::new() -> People {\n  {\n    name: "",\n  }\n}\n`,
    },
    {
      input: '{"oddCase1": "yo"}',
      expected: `pub struct AutoGenerated {\n  oddCase1 : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    oddCase1: "",\n  }\n}\n`,
    },
    {
      input: '{"odd_case_2": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case_2 : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    odd_case_2: "",\n  }\n}\n`,
    },
    {
      input: '{"odd_case3": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case3 : String\n} derive(Show, Eq, ToJson, FromJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    odd_case3: "",\n  }\n}\n`,
    },
  ]

  for (const testCase of testCases) {
    const got = jsonToMoonBit(testCase.input, null, null, includeExampleData)
    if (got.error) {
      console.assert(!got.error, `format('${testCase.input}'): ${got.error}`)
      process.exitCode = 16
    } else {
      const exp = includeExampleData ? testCase.expectedWithExample : testCase.expected
      const success = got.moonbit === exp
      console.assert(success,
        `format('${testCase.input}'): \n  got:  ${quote(got.moonbit)}\n  want: ${quote(exp)}`
      )
      if (!success) process.exitCode = 17
    }
  }
  console.log(includeExampleData ? 'done testing samples with data' : 'done testing samples without data')
}

function testFiles() {
  const fs = require('fs')
  const path = require('path')

  const testCases = [
    'test1/array-with-mixed-float-int',
    'test2/array-with-nonmatching-types',
    'test3/double-nested-objects',
    'test4/duplicate-top-level-structs',
    'test5/smarty-streets-api',
    'test6/struct-of-array-of-struct',
    'test7/github-api-omitempty',
  ]

  for (const testCase of testCases) {
    console.log(`\nRunning testCase: '${testCase}'`)
    try {
      const jsonData = fs.readFileSync(path.join('tests', testCase + '.json'), 'utf8')
      const expectedMoonBitFilename = path.join('tests', testCase + '.mbt')
      const expectedMoonBitData = fs.readFileSync(expectedMoonBitFilename, 'utf8')
      const allOmitempty = testCase.startsWith('test7')
      const got = jsonToMoonBit(jsonData, null, true, false, allOmitempty)
      if (got.error) {
        console.assert(!got.error, `format('${jsonData}'): ${got.error}`)
        process.exitCode = 18
      } else {
        const success = got.moonbit === expectedMoonBitData
        if (!success) {
          const diffs = Diff.diffLines(got.moonbit, expectedMoonBitData)
          const patch = Diff.createTwoFilesPatch(expectedMoonBitFilename, "got.moonbit", expectedMoonBitData, got.moonbit)
          console.error(`got:\n${got.moonbit}`)
          console.error(`diffs:\n${patch}`)
          process.exitCode = 19
        }
      }
    } catch (err) {
      console.error(err)
      process.exitCode = 20
    }
  }
  console.log('done testing files')
}

test(false)
testFiles()
