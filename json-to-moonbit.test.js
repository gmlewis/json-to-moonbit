// -*- compile-command: "bun json-to-moonbit.test.js"; -*-

const jsonToMoonBit = require("./json-to-moonbit")
const Diff = require('./diff.min')

function quote(str) {
  return "'" + str
    .replace(/\t/g, '  ')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/'/g, "\\'") + "'"
}

function test(includeExampleData) {
  const testCases = [
    {
      input: '{"html_url":"a","ssh_url":"b"}',
      expected: `pub struct AutoGenerated {\n  html_url : String\n  ssh_url : String\n} derive(Show, Eq, ToJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    html_url: "",\n    ssh_url: "",\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let html_url : String = match json.get("html_url") {\n    Some(String(html_url)) => html_url\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:html_url: expected String"))\n  }\n  let ssh_url : String = match json.get("ssh_url") {\n    Some(String(ssh_url)) => ssh_url\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:ssh_url: expected String"))\n  }\n  {\n    html_url,\n    ssh_url,\n  }\n}\n`,
    },
    {
      input: '{"SourceCode": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["SourceCode"] = self.source_code.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let source_code : String = match json.get("SourceCode") {\n    Some(String(source_code)) => source_code\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:source_code: expected String"))\n  }\n  {\n    source_code,\n  }\n}\n`,
    },
    {
      input: '{"source_code": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq, ToJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let source_code : String = match json.get("source_code") {\n    Some(String(source_code)) => source_code\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:source_code: expected String"))\n  }\n  {\n    source_code,\n  }\n}\n`,
    },
    {
      input: '{"sourceCode": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["sourceCode"] = self.source_code.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let source_code : String = match json.get("sourceCode") {\n    Some(String(source_code)) => source_code\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:source_code: expected String"))\n  }\n  {\n    source_code,\n  }\n}\n`,
    },
    {
      input: '{"SOURCE_CODE": ""}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    source_code: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["SOURCE_CODE"] = self.source_code.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let source_code : String = match json.get("SOURCE_CODE") {\n    Some(String(source_code)) => source_code\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:source_code: expected String"))\n  }\n  {\n    source_code,\n  }\n}\n`,
    },
    {
      input: '{"PublicIP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["PublicIP"] = self.public_ip.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("PublicIP") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"public_ip": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq, ToJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("public_ip") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"publicIP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["publicIP"] = self.public_ip.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("publicIP") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"publicIp": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["publicIp"] = self.public_ip.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("publicIp") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"PUBLIC_IP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    public_ip: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["PUBLIC_IP"] = self.public_ip.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let public_ip : String = match json.get("PUBLIC_IP") {\n    Some(String(public_ip)) => public_ip\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:public_ip: expected String"))\n  }\n  {\n    public_ip,\n  }\n}\n`,
    },
    {
      input: '{"+1": "Fails", "-1": "This should not cause duplicate field name"}',
      expected: `pub struct AutoGenerated {\n  num1 : String\n  num10 : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    num1: "",\n    num10: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["+1"] = self.num1.to_json()\n  json["-1"] = self.num10.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let num1 : String = match json.get("+1") {\n    Some(String(num1)) => num1\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:num1: expected String"))\n  }\n  let num10 : String = match json.get("-1") {\n    Some(String(num10)) => num10\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:num10: expected String"))\n  }\n  {\n    num1,\n    num10,\n  }\n}\n`,
    },
    {
      input: '{"age": 46}',
      expected: `pub struct AutoGenerated {\n  age : Int\n} derive(Show, Eq, ToJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    age: 0,\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let age : Int = match json.get("age") {\n    Some(Number(age)) => age.to_int()\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:age expected Int"))\n  }\n  {\n    age,\n  }\n}\n`,
    },
    {
      input: '{"negativeFloat": -1.00}',
      expected: `pub struct AutoGenerated {\n  negative_float : Double\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    negative_float: 0,\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["negativeFloat"] = self.negative_float.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let negative_float : Double = match json.get("negativeFloat") {\n    Some(Number(negative_float)) => negative_float\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:negative_float: expected Double"))\n  }\n  {\n    negative_float,\n  }\n}\n`,
    },
    {
      input: '{"zeroFloat": 0.00}',
      expected: `pub struct AutoGenerated {\n  zero_float : Double\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    zero_float: 0,\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["zeroFloat"] = self.zero_float.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let zero_float : Double = match json.get("zeroFloat") {\n    Some(Number(zero_float)) => zero_float\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:zero_float: expected Double"))\n  }\n  {\n    zero_float,\n  }\n}\n`,
    },
    {
      input: '{"positiveFloat": 1.00}',
      expected: `pub struct AutoGenerated {\n  positive_float : Double\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    positive_float: 0,\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["positiveFloat"] = self.positive_float.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let positive_float : Double = match json.get("positiveFloat") {\n    Some(Number(positive_float)) => positive_float\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:positive_float: expected Double"))\n  }\n  {\n    positive_float,\n  }\n}\n`,
    },
    {
      input: '{"negativeFloats": [-1.00, -2.00, -3.00]}',
      expected: `pub struct AutoGenerated {\n  negative_floats : Array[Double]\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    negative_floats: [],\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["negativeFloats"] = self.negative_floats.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let negative_floats : Array[NegativeFloats] = match json.get("negativeFloats") {\n    Some(Array(negative_floats)) => negative_floats_array_from_json!(negative_floats)\n    e => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:negative_floats: expected Array: got \\{e}"))\n  }\n  {\n    negative_floats,\n  }\n}\n\npub fn negative_floats_array_from_json(json : Array[Json]) -> Array[NegativeFloats]!@json.JsonDecodeError {\n  let arr: Array[NegativeFloats] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : NegativeFloats = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"zeroFloats": [0.00, 0.00, 0.00]}',
      expected: `pub struct AutoGenerated {\n  zero_floats : Array[Double]\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    zero_floats: [],\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["zeroFloats"] = self.zero_floats.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let zero_floats : Array[ZeroFloats] = match json.get("zeroFloats") {\n    Some(Array(zero_floats)) => zero_floats_array_from_json!(zero_floats)\n    e => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:zero_floats: expected Array: got \\{e}"))\n  }\n  {\n    zero_floats,\n  }\n}\n\npub fn zero_floats_array_from_json(json : Array[Json]) -> Array[ZeroFloats]!@json.JsonDecodeError {\n  let arr: Array[ZeroFloats] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : ZeroFloats = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"positiveFloats": [1.00, 2.00, 3.00]}',
      expected: `pub struct AutoGenerated {\n  positive_floats : Array[Double]\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    positive_floats: [],\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["positiveFloats"] = self.positive_floats.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let positive_floats : Array[PositiveFloats] = match json.get("positiveFloats") {\n    Some(Array(positive_floats)) => positive_floats_array_from_json!(positive_floats)\n    e => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:positive_floats: expected Array: got \\{e}"))\n  }\n  {\n    positive_floats,\n  }\n}\n\npub fn positive_floats_array_from_json(json : Array[Json]) -> Array[PositiveFloats]!@json.JsonDecodeError {\n  let arr: Array[PositiveFloats] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : PositiveFloats = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"topLevel": { "secondLevel": "exampleDataHere"} }',
      expected: `pub struct AutoGenerated {\n  top_level : TopLevel\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    top_level: TopLevel::new(),\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["topLevel"] = self.top_level.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let top_level : TopLevel = match json.get("topLevel") {\n    Some(Object(top_level)) => @json.from_json!(top_level.to_json())\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:top_level expected TopLevel"))\n  }\n  {\n    top_level,\n  }\n}\n\npub struct TopLevel {\n  second_level : String\n} derive(Show, Eq)\n\npub fn TopLevel::new() -> TopLevel {\n  {\n    second_level: "",\n  }\n}\n\npub fn to_json(self : TopLevel) -> Json {\n  let json : Map[String, Json] = {}\n  json["secondLevel"] = self.second_level.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for TopLevel with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "TopLevel::from_json: expected object"),\n      )\n  }\n  let second_level : String = match json.get("secondLevel") {\n    Some(String(second_level)) => second_level\n    _ => raise @json.JsonDecodeError((path, "TopLevel::from_json:second_level: expected String"))\n  }\n  {\n    second_level,\n  }\n}\n`,
    },
    {
      input: '{"people": [{ "name": "Frank"}, {"name": "Dennis"}, {"name": "Dee"}, {"name": "Charley"}, {"name":"Mac"}] }',
      expected: `pub struct AutoGenerated {\n  people : Array[People]\n} derive(Show, Eq, ToJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    people: [],\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let people : Array[People] = match json.get("people") {\n    Some(Array(people)) => people_array_from_json!(people)\n    e => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:people: expected Array: got \\{e}"))\n  }\n  {\n    people,\n  }\n}\n\npub fn people_array_from_json(json : Array[Json]) -> Array[People]!@json.JsonDecodeError {\n  let arr: Array[People] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : People = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\npub struct People {\n  name : String\n} derive(Show, Eq, ToJson)\n\npub fn People::new() -> People {\n  {\n    name: "",\n  }\n}\n\npub impl @json.FromJson for People with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "People::from_json: expected object"),\n      )\n  }\n  let name : String = match json.get("name") {\n    Some(String(name)) => name\n    _ => raise @json.JsonDecodeError((path, "People::from_json:name: expected String"))\n  }\n  {\n    name,\n  }\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"oddCase1": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case1 : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    odd_case1: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["oddCase1"] = self.odd_case1.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let odd_case1 : String = match json.get("oddCase1") {\n    Some(String(odd_case1)) => odd_case1\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:odd_case1: expected String"))\n  }\n  {\n    odd_case1,\n  }\n}\n`,
    },
    {
      input: '{"odd_case_2": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case2 : String\n} derive(Show, Eq)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    odd_case2: "",\n  }\n}\n\npub fn to_json(self : AutoGenerated) -> Json {\n  let json : Map[String, Json] = {}\n  json["odd_case_2"] = self.odd_case2.to_json()\n  json.to_json()\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let odd_case2 : String = match json.get("odd_case_2") {\n    Some(String(odd_case2)) => odd_case2\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:odd_case2: expected String"))\n  }\n  {\n    odd_case2,\n  }\n}\n`,
    },
    {
      input: '{"odd_case3": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case3 : String\n} derive(Show, Eq, ToJson)\n\npub fn AutoGenerated::new() -> AutoGenerated {\n  {\n    odd_case3: "",\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  let json = match json.as_object() {\n    Some(json) => json\n    _ =>\n      raise @json.JsonDecodeError(\n        (path, "AutoGenerated::from_json: expected object"),\n      )\n  }\n  let odd_case3 : String = match json.get("odd_case3") {\n    Some(String(odd_case3)) => odd_case3\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json:odd_case3: expected String"))\n  }\n  {\n    odd_case3,\n  }\n}\n`,
    },
  ]

  for (const testCase of testCases) {
    const got = jsonToMoonBit(testCase.input, null, null, includeExampleData)
    if (got.error) {
      console.assert(!got.error, `format('${testCase.input}'): ${got.error}`)
      process.exitCode = 16
    } else {
      const exp = includeExampleData ? testCase.expectedWithExample : testCase.expected
      const success = got.moonbit === exp
      console.assert(success,
        `format('${testCase.input}'): \n  got:  ${quote(got.moonbit)}\n  want: ${quote(exp)}`
      )
      if (!success) process.exitCode = 17
    }
  }
  console.log(includeExampleData ? 'done testing samples with data' : 'done testing samples without data')
}

function testFiles() {
  const fs = require('fs')
  const path = require('path')

  const testCases = [
    'test1/array-with-mixed-float-int',
    'test2/array-with-nonmatching-types',
    'test3/double-nested-objects',
    'test4/duplicate-top-level-structs',
    'test5/smarty-streets-api',
    'test6/struct-of-array-of-struct',
    'test7/github-api-omitempty',
  ]

  for (const testCase of testCases) {
    console.log(`\nRunning testCase: '${testCase}'`)
    try {
      const jsonData = fs.readFileSync(path.join('tests', testCase + '.json'), 'utf8')
      const expectedMoonBitFilename = path.join('tests', testCase + '.mbt')
      const expectedMoonBitData = fs.readFileSync(expectedMoonBitFilename, 'utf8')
      const allOmitempty = testCase.startsWith('test7')
      const got = jsonToMoonBit(jsonData, null, true, false, allOmitempty)
      if (got.error) {
        console.assert(!got.error, `format('${jsonData}'): ${got.error}`)
        process.exitCode = 18
      } else {
        const success = got.moonbit === expectedMoonBitData
        if (!success) {
          const diffs = Diff.diffLines(got.moonbit, expectedMoonBitData)
          const patch = Diff.createTwoFilesPatch(expectedMoonBitFilename, "got.moonbit", expectedMoonBitData, got.moonbit)
          console.error(`got:\n${got.moonbit}`)
          console.error(`diffs:\n${patch}`)
          process.exitCode = 19
        }
      }
    } catch (err) {
      console.error(err)
      process.exitCode = 20
    }
  }
  console.log('done testing files')
}

test(false)
testFiles()
