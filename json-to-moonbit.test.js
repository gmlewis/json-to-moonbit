// -*- compile-command: "bun json-to-moonbit.test.js"; -*-

const jsonToMoonBit = require("./json-to-moonbit")
const Diff = require('./diff.min')

function quote(str) {
  return "'" + str
    .replace(/\t/g, '  ')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/'/g, "\\'") + "'"
}

function test(includeExampleData) {
  const testCases = [
    {
      input: '{"html_url":"a","ssh_url":"b"}',
      expected: `pub struct AutoGenerated {\n  html_url : String\n  ssh_url : String\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "html_url": String(html_url),\n      "ssh_url": String(ssh_url),\n    } => {\n      {\n        html_url,\n        ssh_url,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"SourceCode": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "SourceCode": self.source_code.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "SourceCode": String(source_code),\n    } => {\n      {\n        source_code,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"source_code": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "source_code": String(source_code),\n    } => {\n      {\n        source_code,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"sourceCode": "exampleDataHere"}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "sourceCode": self.source_code.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "sourceCode": String(source_code),\n    } => {\n      {\n        source_code,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"SOURCE_CODE": ""}',
      expected: `pub struct AutoGenerated {\n  source_code : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "SOURCE_CODE": self.source_code.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "SOURCE_CODE": String(source_code),\n    } => {\n      {\n        source_code,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"PublicIP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "PublicIP": self.public_ip.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "PublicIP": String(public_ip),\n    } => {\n      {\n        public_ip,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"public_ip": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "public_ip": String(public_ip),\n    } => {\n      {\n        public_ip,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"publicIP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "publicIP": self.public_ip.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "publicIP": String(public_ip),\n    } => {\n      {\n        public_ip,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"publicIp": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "publicIp": self.public_ip.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "publicIp": String(public_ip),\n    } => {\n      {\n        public_ip,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"PUBLIC_IP": ""}',
      expected: `pub struct AutoGenerated {\n  public_ip : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "PUBLIC_IP": self.public_ip.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "PUBLIC_IP": String(public_ip),\n    } => {\n      {\n        public_ip,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"+1": "Fails", "-1": "This should not cause duplicate field name"}',
      expected: `pub struct AutoGenerated {\n  num1 : String\n  num10 : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "+1": self.num1.to_json(),\n    "-1": self.num10.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "+1": String(num1),\n      "-1": String(num10),\n    } => {\n      {\n        num1,\n        num10,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"age": 46}',
      expected: `pub struct AutoGenerated {\n  age : Int\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "age": Number(age),\n    } => {\n      let age = age.to_int()\n      {\n        age,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"negativeFloat": -1.00}',
      expected: `pub struct AutoGenerated {\n  negative_float : Double\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "negativeFloat": self.negative_float.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "negativeFloat": Number(negative_float),\n    } => {\n      {\n        negative_float,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"zeroFloat": 0.00}',
      expected: `pub struct AutoGenerated {\n  zero_float : Double\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "zeroFloat": self.zero_float.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "zeroFloat": Number(zero_float),\n    } => {\n      {\n        zero_float,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"positiveFloat": 1.00}',
      expected: `pub struct AutoGenerated {\n  positive_float : Double\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "positiveFloat": self.positive_float.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "positiveFloat": Number(positive_float),\n    } => {\n      {\n        positive_float,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"negativeFloats": [-1.00, -2.00, -3.00]}',
      expected: `pub struct AutoGenerated {\n  negative_floats : Array[Double]\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "negativeFloats": self.negative_floats.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "negativeFloats": Array(negative_floats),\n    } => {\n      let negative_floats : Array[NegativeFloats] = negative_floats_array_from_json!(negative_floats)\n      {\n        negative_floats,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n\npub fn negative_floats_array_from_json(json : Array[Json]) -> Array[NegativeFloats]!@json.JsonDecodeError {\n  let arr: Array[NegativeFloats] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : NegativeFloats = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"zeroFloats": [0.00, 0.00, 0.00]}',
      expected: `pub struct AutoGenerated {\n  zero_floats : Array[Double]\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "zeroFloats": self.zero_floats.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "zeroFloats": Array(zero_floats),\n    } => {\n      let zero_floats : Array[ZeroFloats] = zero_floats_array_from_json!(zero_floats)\n      {\n        zero_floats,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n\npub fn zero_floats_array_from_json(json : Array[Json]) -> Array[ZeroFloats]!@json.JsonDecodeError {\n  let arr: Array[ZeroFloats] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : ZeroFloats = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"positiveFloats": [1.00, 2.00, 3.00]}',
      expected: `pub struct AutoGenerated {\n  positive_floats : Array[Double]\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "positiveFloats": self.positive_floats.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "positiveFloats": Array(positive_floats),\n    } => {\n      let positive_floats : Array[PositiveFloats] = positive_floats_array_from_json!(positive_floats)\n      {\n        positive_floats,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n\npub fn positive_floats_array_from_json(json : Array[Json]) -> Array[PositiveFloats]!@json.JsonDecodeError {\n  let arr: Array[PositiveFloats] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : PositiveFloats = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"topLevel": { "secondLevel": "exampleDataHere"} }',
      expected: `pub struct AutoGenerated {\n  top_level : TopLevel\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "topLevel": self.top_level.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "topLevel": top_level,\n    } => {\n      let top_level : TopLevel = @json.from_json!(top_level)\n      {\n        top_level,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n\npub struct TopLevel {\n  second_level : String\n} derive(Show, Eq)\n\npub fn to_json(self : TopLevel) -> Json {\n  {\n    "secondLevel": self.second_level.to_json(),\n  }\n}\n\npub impl @json.FromJson for TopLevel with from_json(json, path) {\n  match json {\n    {\n      "secondLevel": String(second_level),\n    } => {\n      {\n        second_level,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "TopLevel::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"people": [{ "name": "Frank"}, {"name": "Dennis"}, {"name": "Dee"}, {"name": "Charley"}, {"name":"Mac"}] }',
      expected: `pub struct AutoGenerated {\n  people : Array[People]\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "people": Array(people),\n    } => {\n      let people : Array[People] = people_array_from_json!(people)\n      {\n        people,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n\npub fn people_array_from_json(json : Array[Json]) -> Array[People]!@json.JsonDecodeError {\n  let arr: Array[People] = Array::new(capacity = json.length())\n  each_exn!(\n    json,\n    fn(jv) {\n      let el : People = @json.from_json!(jv)\n      arr.push(el)\n    }\n  )\n  arr\n}\n\npub struct People {\n  name : String\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for People with from_json(json, path) {\n  match json {\n    {\n      "name": String(name),\n    } => {\n      {\n        name,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "People::from_json: expected object"))\n  }\n}\n\nfn each_exn[T](arr : Array[T], func : (T) -> Unit!@json.JsonDecodeError) -> Unit!@json.JsonDecodeError {\n  for i = 0; i < arr.length(); i = i + 1 {\n    func!(arr[i])\n  }\n}\n`,
    },
    {
      input: '{"oddCase1": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case1 : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "oddCase1": self.odd_case1.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "oddCase1": String(odd_case1),\n    } => {\n      {\n        odd_case1,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"odd_case_2": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case2 : String\n} derive(Show, Eq)\n\npub fn to_json(self : AutoGenerated) -> Json {\n  {\n    "odd_case_2": self.odd_case2.to_json(),\n  }\n}\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "odd_case_2": String(odd_case2),\n    } => {\n      {\n        odd_case2,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
    {
      input: '{"odd_case3": "yo"}',
      expected: `pub struct AutoGenerated {\n  odd_case3 : String\n} derive(Show, Eq, ToJson)\n\npub impl @json.FromJson for AutoGenerated with from_json(json, path) {\n  match json {\n    {\n      "odd_case3": String(odd_case3),\n    } => {\n      {\n        odd_case3,\n      }\n    }\n    _ => raise @json.JsonDecodeError((path, "AutoGenerated::from_json: expected object"))\n  }\n}\n`,
    },
  ]

  for (const testCase of testCases) {
    const got = jsonToMoonBit(testCase.input, null, null, includeExampleData)
    if (got.error) {
      console.assert(!got.error, `format('${testCase.input}'): ${got.error}`)
      process.exitCode = 16
    } else {
      const exp = includeExampleData ? testCase.expectedWithExample : testCase.expected
      const success = got.moonbit === exp
      console.assert(success,
        `format('${testCase.input}'): \n  got:  ${quote(got.moonbit)}\n  want: ${quote(exp)}`
      )
      if (!success) process.exitCode = 17
    }
  }
  console.log(includeExampleData ? 'done testing samples with data' : 'done testing samples without data')
}

function testFiles() {
  const fs = require('fs')
  const path = require('path')

  const testCases = [
    'test1/array-with-mixed-float-int',
    'test2/array-with-nonmatching-types',
    'test3/double-nested-objects',
    'test4/duplicate-top-level-structs',
    'test5/smarty-streets-api',
//GML: TODO:     'test6/struct-of-array-of-struct',
    'test7/github-api-omitempty',
  ]

  for (const testCase of testCases) {
    console.log(`\nRunning testCase: '${testCase}'`)
    try {
      const jsonData = fs.readFileSync(path.join('tests', testCase + '.json'), 'utf8')
      const expectedMoonBitFilename = path.join('tests', testCase + '.mbt')
      const expectedMoonBitData = fs.readFileSync(expectedMoonBitFilename, 'utf8')
      const allOmitempty = testCase.startsWith('test7')
      const got = jsonToMoonBit(jsonData, null, true, false, allOmitempty)
      if (got.error) {
        console.assert(!got.error, `format('${jsonData}'): ${got.error}`)
        process.exitCode = 18
      } else {
        const success = got.moonbit === expectedMoonBitData
        if (!success) {
          const diffs = Diff.diffLines(got.moonbit, expectedMoonBitData)
          const patch = Diff.createTwoFilesPatch(expectedMoonBitFilename, "got.moonbit", expectedMoonBitData, got.moonbit)
          console.error(`got:\n${got.moonbit}`)
          console.error(`diffs:\n${patch}`)
          process.exitCode = 19
        }
      }
    } catch (err) {
      console.error(err)
      process.exitCode = 20
    }
  }
  console.log('done testing files')
}

//GML: TODO:  test(false)
testFiles()
